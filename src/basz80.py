"""
Translates intermediate code generated by the Emitter object
to Amstrad CPC Z80 Assembly language in Maxam/WinAPE style.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation in its version 3.

This program is distributed in the hope that it will be useful
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
"""

import sys
from basz80lib import SM2Z80, FWCALL, STRLIB
from bastypes import BASTypes

class Z80Backend:
    """
    Generates code for Amstrad CPC in Z80 Assembly language (Maxam/WinAPE style)
    """

    def __init__(self):
        self.symbols = None
        self.libs = []
        self.icode = []
        self.libcode = ["\n","; LIBRARY AREA\n", "\n"]  # reusable and utility asm subroutines
        self.code = []                                  # program code
        self.data = ["\n","; DATA AREA\n", "\n"]        # data/constants declaration area    

    def abort(self, message):
        print("Fatal error:", message)
        sys.exit(1)

    def save_output(self):
        with open(self.outputfile, 'w  ') as ofd:
            ofd.writelines(self.libcode)
            ofd.writelines(self.code)
            ofd.writelines(self.data)
        return self.outputfile


    def emitlibcode(self, code):
        self.libcode.append(code + '\n')

    def emitcode(self, inst, arg, prefix):
        if inst == "LIBCALL":
            # BASIC original function
            self.emit_rtcall(arg)
        elif inst in SM2Z80:
            code = SM2Z80[inst]
            for line in code:
                if arg != None: line = line.replace('$ARG1', arg)
                self.code.append(prefix + line + '\n')
        else:
            self.abort(f"intermediate op-code {inst} is unknown")

    def emitdata(self, code):
        self.data.append(code + '\n')

    def generatecode(self, orgaddr):
        self.code.append('org &%04X\n' % orgaddr)
        self.code = self.code + ["\n","; CODE AREA\n", "\n"]

        for inst, arg, prefix in self.icode:
            self.emitcode(inst, arg, prefix)
        
        self.code.append("endloop: goto endloop\n") # AAA TEMPORAL
        
        for symname in self.symbols.getsymbols():
            symbol = self.symbols.get(symname)
            if symbol.valtype == BASTypes.INT:
                self.emitdata(f'{symbol.symbol}: dw 0')
            elif symbol.valtype == BASTypes.REAL:
                self.emitdata(f'{symbol.symbol}: dw 0,0')
            elif symbol.valtype == BASTypes.STR:
                if symbol.is_constant():
                    self.emitdata(f'{symbol.symbol}: db "{symbol.value[0]}",&00')
                else:    
                    self.emitdata(f'{symbol.symbol}: defs 255')
            else:
                # This symbol is a label that was processed by LABEL instruction
                pass

    def save_output(self, outputfile, icode, symbols, startaddr = 0x4000):
        """
        outputfile: output file where assembly code will be written
        icode: Intermediate code generated by the Emitter
        symbols: SymbolTable generated by the parser
        startaddr: Starting memory position for the code generated
        """
        self.symbols = symbols
        self.icode = icode
        self.generatecode(startaddr)
        with open(outputfile, "w") as fd:
            fd.writelines(self.code)
            fd.writelines(self.libcode)
            fd.writelines(self.data)

    # BASIC commands and functions

    def emit_rtcall(self, fun):
        fun_cb = getattr(self, "rtcall_" + fun, None)
        if fun_cb == None:
            print("Emitter error:", fun, "call is not implemented yet")
        else:
            fun_cb()

    def _addcode(self, line):
        self.code.append(line + '\n')

    def _addlibfunc(self, lib, fname):
        if fname not in self.libs:
            self.libs.append(fname)
            fcode = lib[fname]
            self.libcode = self.libcode + fcode

    def rtcall_CLS(self):
        self._addcode("\tld      a,l")
        self._addcode("\tand     &07   ;valid stream range 0-7")
        self._addcode(f"\tcall    {FWCALL.TXT_STR_SELECT} ;TXT_STR_SELECT")
        self._addcode(f"\tcall    {FWCALL.TXT_CLEAR_WINDOW} ;TXT_CLEAR_WINDOW")
        self._addcode("\tpop     hl")

    def rtcall_MODE(self):
        self._addcode("\tpush    af")
        self._addcode("\tld      a,l")
        self._addcode("\tpush    hl")
        self._addcode(f"\tcall    {FWCALL.SCR_SET_MODE} ;SCR_SET_MODE")
        self._addcode("\tpop     hl")
        self._addcode("\tpop     af")

    def rtcall_PRINT(self):
        self._addlibfunc(STRLIB, "strlib_print_nl")
        self._addlibfunc(STRLIB, "strlib_print_str")
        self._addcode("\tcall    strlib_print_str")
