In computer science, Backusâ€“Naur Form (BNF) is a metasyntax used to express 
context-free grammars: that is, a formal way to describe formal languages. 
John Backus and Peter Naur developed a context free grammar to define the syntax
of a programming language by using two sets of rules: i.e., lexical rules and
syntactic rules.

BNF is widely used as a notation for the grammars of computer programming languages,
instruction sets and communication protocols, as well as a notation for representing
parts of natural language grammars. Many textbooks for programming language theory
and/or semantics document the programming language in BNF.

The above text and the examples that helped to shape the BNF grammar for the
Amstrad Locomotive BASIC are taken from:

https://rosettacode.org/wiki/BNF_Grammar

"Name"    = 'BASIC (Beginners All-purpose Symbolic Instruction Code) 64'
"Author"  = 'John G. Kemeny and Thomas E. Kurtz' 
"Version" = '1964 - Original - before Microsoft enhanced the language for the IBM PC.'
"About"   = 'BASIC is one of most common and popular teaching languages ever created. '

"Case Sensitive" = False 
"Start Symbol"   = <Lines>

{String Chars} = {Printable} - ["]
{WS}           = {Whitespace} - {CR} - {LF}

NewLine        = {CR}{LF}|{CR}
Whitespace     = {WS}+

Remark         = REM{Space}{Printable}*
ID             = {Letter}[$%]? 
String         = '"'{String Chars}*'"' 
Integer        = {digit}+ 
Real           = {digit}+.{digit}+ 

<Lines>       ::= Integer <Statements> NewLine <Lines> 
                | Integer <Statements> NewLine

<Statements>  ::= <Statement> ':' <Statements>
                | <Statement>

<Statement>   ::= CLOSE '#' Integer
                | DATA <Constant List> 
                | DIM ID '(' <Integer List> ')'
                | END          
                | FOR ID '=' <Expression> TO <Expression>     
                | FOR ID '=' <Expression> TO <Expression> STEP Integer      
                | GOTO <Expression> 
                | GOSUB <Expression> 
                | IF <Expression> THEN <Statement>         
                | INPUT <ID List>       
                | INPUT '#' Integer ',' <ID List>       
                | LET Id '=' <Expression> 
                | NEXT <ID List>               
                | OPEN <Value> FOR <Access> AS '#' Integer
                | POKE <Value List>
                | PRINT <Print list>
                | PRINT '#' Integer ',' <Print List>
                | READ <ID List>           
                | RETURN
                | RESTORE
                | RUN
                | STOP
                | SYS <Value>
                | WAIT <Value List>
                | Remark

<Access>   ::= INPUT
             | OUPUT
                   
<ID List>  ::= ID ',' <ID List> 
             | ID 

<Value List>      ::= <Value> ',' <Value List> 
                    | <Value> 

<Constant List>   ::= <Constant> ',' <Constant List> 
                    | <Constant> 

<Integer List>    ::= Integer ',' <Integer List>
                    | Integer
                 
<Expression List> ::= <Expression> ',' <Expression List> 
                    | <Expression> 

<Print List>      ::= <Expression> ';' <Print List>
                    | <Expression> 
                    |  

<Expression>  ::= <And Exp> OR <Expression> 
                | <And Exp> 

<And Exp>     ::= <Not Exp> AND <And Exp> 
                | <Not Exp> 
 
<Not Exp>     ::= NOT <Compare Exp> 
                | <Compare Exp> 

<Compare Exp> ::= <Add Exp> '='  <Compare Exp> 
                | <Add Exp> '<>' <Compare Exp> 
                | <Add Exp> '><' <Compare Exp> 
                | <Add Exp> '>'  <Compare Exp> 
                | <Add Exp> '>=' <Compare Exp> 
                | <Add Exp> '<'  <Compare Exp> 
                | <Add Exp> '<=' <Compare Exp> 
                | <Add Exp> 

<Add Exp>     ::= <Mult Exp> '+' <Add Exp> 
                | <Mult Exp> '-' <Add Exp> 
                | <Mult Exp> 

<Mult Exp>    ::= <Negate Exp> '*' <Mult Exp> 
                | <Negate Exp> '/' <Mult Exp> 
                | <Negate Exp> 

<Negate Exp>  ::= '-' <Power Exp> 
                | <Power Exp> 

<Power Exp>   ::= <Power Exp> '^' <Value> 
                | <Value> 

<Value>       ::= '(' <Expression> ')'
                | ID 
                | ID '(' <Expression List> ')'
                | <Constant> 

<Constant> ::= Integer 
             | String 
             | Real 


"Name"    = 'Commodore PET BASIC'
"Author"  = 'Commodore Business Machines'
"Version" = '2.0'
"About"   = 'This is the version of BASIC that was used on the Commodore 64.'

"Case Sensitive" = False 
"Start Symbol"   = <Lines>

{String Chars} = {Printable} - ["]
{WS}           = {Whitespace} - {CR} - {LF}

NewLine        = {CR}{LF}|{CR}
Whitespace     = {WS}+

Remark         = REM{Space}{Printable}*
ID             = {Letter}{Alphanumeric}?[$%]?      !IDs are can only have a maximum of 2 characters
FunctionID     = FN {Letter}{Letter}?

String         = '"'{String Chars}*'"' 
Integer        = {Digit}+ 
Real           = {Digit}+'.'{Digit}+ 

<Lines>       ::= <Lines> <Line>
                | <Line>

<Line>        ::= Integer <Statements> NewLine 
                                
<Statements>  ::= <Statements> ':' <Statement>
                | <Statement>

<Statement>   ::= CLOSE Integer
                | CLR
                | CMD  <Expression>
                | CONT                                          !Continue
                | DATA <Constant List> 
                | DEF FunctionID '(' <ID List> ')' '=' <Expression>    !The ID must start with FN
                | DIM ID '(' <Expression List> ')'
                | END          
                | FOR ID '=' <Expression> TO <Expression> <Step Opt>     
                | GET ID
                | GET '#' Integer ',' ID
                | GOSUB <Expression> 
                | GOTO <Expression>                 
                | IF <Expression> THEN <Then Clause>                
                | INPUT <ID List>       
                | INPUT '#' Integer ',' <ID List>       
                | LET ID '=' <Expression> 
                | LIST <Line Range>
                | LOAD <Value List>        
                | ID '=' <Expression> 
                | NEW
                | NEXT <ID List>               
                | ON ID GOTO <Expression List>
                | OPEN <Expression List>         
                | POKE <Expression> ',' <Expression>
                | PRINT <Print list>
                | PRINT '#' Integer ',' <Print List>
                | READ <ID List>           
                | RETURN
                | RESTORE
                | RUN
                | RUN <Expression>
                | STOP
                | SYS <Expression>
                | WAIT <Expression List>     
                | VERIFY <Expression List>     
                | Remark

<Step Opt> ::= STEP <Expression>
             | 
                   
<ID List>  ::= ID ',' <ID List> 
             | ID 

<Value List>      ::= <Value> ',' <Value List> 
                    | <Value> 

<Constant List>   ::= <Constant> ',' <Constant List> 
                    | <Constant> 
                 
<Expression List> ::= <Expression> ',' <Expression List> 
                    | <Expression> 

<Print List>      ::= <Expression> ';' <Print List>
                    | <Expression> 
                    |  

<Line Range>  ::= Integer 
                | Integer '-'
                | Integer '-' Integer 

<Then Clause> ::= Integer
                | <Statement>

! ----------------------------------------------- Expressions

<Expression>  ::= <And Exp> OR <Expression> 
                | <And Exp> 

<And Exp>     ::= <Not Exp> AND <And Exp> 
                | <Not Exp> 
 
<Not Exp>     ::= NOT <Compare Exp> 
                | <Compare Exp> 

<Compare Exp> ::= <Add Exp> '='  <Compare Exp> 
                | <Add Exp> '<>' <Compare Exp> 
                | <Add Exp> '>'  <Compare Exp> 
                | <Add Exp> '>=' <Compare Exp> 
                | <Add Exp> '<'  <Compare Exp> 
                | <Add Exp> '<=' <Compare Exp> 
                | <Add Exp> 

<Add Exp>     ::= <Mult Exp> '+' <Add Exp> 
                | <Mult Exp> '-' <Add Exp> 
                | <Mult Exp> 

<Mult Exp>    ::= <Negate Exp> '*' <Mult Exp> 
                | <Negate Exp> '/' <Mult Exp> 
                | <Negate Exp> 

<Negate Exp>  ::= '-' <Power Exp> 
                | <Power Exp> 

<Power Exp>   ::= <Power Exp> '^' <Sub Exp>        !On the Commodore, the symbol was an up-arrow
                | <Sub Exp> 

<Sub Exp>     ::= '(' <Expression> ')'
                | <Value>

<Value>       ::= ID 
                | ABS        '(' <Expression> ')'
                | ASC        '(' <Expression> ')'
                | ATN        '(' <Expression> ')'
                | 'CHR$'     '(' <Expression> ')'
                | COS        '(' <Expression> ')'
                | EXP        '(' <Expression> ')'
                | FunctionID '(' <Expression List> ')'
                | FRE        '(' <Value> ')'                  !The <Value> is  irrelevant
                | INT        '(' <Expression> ')'
                | 'LEFT$'    '(' <Expression> ',' <Expression> ')'
                | LEN        '(' <Expression> ')'
                | PEEK       '(' <Expression> ')'
                | POS        '(' <Value> ')'                  !The <Value> is  irrelevant
                | 'RIGHT$'   '(' <Expression> ',' <Expression> ')'
                | RND        '(' <Expression> ')'
                | SGN        '(' <Expression> ')' 
                | SPC        '(' <Expression> ')' 
                | SQR        '(' <Expression> ')' 
                | TAB        '(' <Expression> ')' 
                | TAN        '(' <Expression> ')' 
                | VAL        '(' <Expression> ')' 
                
                | <Constant> 

<Constant>    ::= Integer 
                | String 
                | Real 


EXPRESSION BNF example

<ADD_OP>   ::= "+" | "-" 
<MUL_OP>   ::= "*" | "/"
<POWER_OP> ::= "^"
<NUMBER>   ::= [0-9]+

/* Just for illustrative purposes, as this production can be left out. */
<expr> ::= <term>

/* A term is composed of a factor, so factor is parsed/produced first */
<term> ::= <term> <ADD_OP> <factor>
    | <factor>
    
/* Left associative, so written as left recursive */
<factor> ::= <factor> <MUL_OP> <power> 
    | <power>
    
/* Right associative, so written as right recursive */
<power> ::= <unary> <POWER_OP> <power>
    | <unary>
    
<unary> ::= "-" <primary>
	| <primary>
    
/* The leaf nodesâ€¦â€¦or parenthesized expressions. */
<primary> ::= <NUMBER>
    | "(" <expr> ")"



LOCOMOTIVE BASIC

BASIC notation

<XXX>       XXX must be typed
()          () must be typed
[]          Optional
& or &H     Prefixes for a hexadecimal number
&X          Prefixes for a binary number
#           Prefixes for an inputs/outputs chanel (stream)

DATA TYPES

<alphanumeric chain>    Contain from 0 to 255 characters. '+' concatenates (max 255).
<whole number>          Vary from -32768 to + 32767.
<real number>           From -1.7E+38 to +1.7E+38
<numerical expression>  Is an expression which leads to a numerical value.All that is not
                        <alphanumeric chain>. Can be REAL numbers.

<chanel number>         <numerical expression> to indicate a screen window, a printer, a
                        cassette or a diskette to which the text must be forwarded.

<list of element>       Describes a list of elements separated by commas.
                        Limited by the line lengh.

Various indicators of data type:
%   Whole (Integer)
!   Reals (by defect)
$   Alphanumeric chain (String)

KEYWORDS AND RESERVED SYMBOLS CAN BE:
* COMMANDS    : operations executed direcly
* FUNCTIONS   : operations intervening in an expression
* OPERATORS   : act with mathematical arguments

KEYWORDS

ABS(<numerical expression>) -- FUNCTION
AFTER <chronometer time>[,<chronometer number>] GOSUB <line number> -- COMMAND
<argument> AND <argument> -- OPERATOR
ASC(<alphanumeric chain>) -- FUNCTION
ATN(<numerical expression>) -- FUNCTION
AUTO [<line number>][,<increment>] -- COMMAND
BIN$ (<whole number without sign>[,<whole number>]) -- FUNCTION
BORDER <color number>[,<color number>] -- COMMAND
CALL <adress>[,<list of:<parameter>] -- COMMAND
CAT -- COMMAND
CHAIN <filename>[,<line number>] -- COMMAND
CHAIN MERGE <filename>[,<line number>][,DELETE <unit of lines>] -- COMMAND
CHR$(<whole number>) -- FUNCTION
CINT(<numerical expression>) -- FUNCTION
CLEAR -- COMMAND
CLEAR INPUT -- COMMAND
CLG [<inks>] -- COMMAND
CLOSEIN -- COMMAND
CLOSEOUT -- COMMAND
CLS [# <channel number>] -- COMMAND
CONT -- COMMAND
COPYCHR$ (# <channel number>) -- FUNCTION
COS (<numerical expression>) -- FUNCTION
CREAL  (<numerical expression>) -- FUNCTION
CURSOR [<system indicator>)][ , <user indicator>] --  COMMAND
DATA <list of:<constant> -- COMMAND
DEC$ (<numerical expression>,<form model>) -- FUNCTION
DEF FN <name>[(<parameters>)]=<expression> -- COMMAND
DEFINT <list of: <letters concerned> -- COMMAND
DEFREAL <list of: <letters concerned> -- COMMAND
DEFSTR <list of: <letters concerned> -- COMMAND
DEG -- COMMAND
DELETE <unit of lines> -- COMMAND
DERR -- FUNCTION
DI -- COMMAND
DIM <list of: <subscripted variable> -- COMMAND
DRAW <coordinate x>,<coordinate y> [,[<ink>][,<ink mode>]] -- COMMAND
DRAWR <interval x>,<interval y> [,[<ink>][,<ink mode>]] -- COMMAND
EDIT <line number> -- COMMAND
EI -- COMMAND
END -- COMMAND
ENT <envelope number> [,<envelope section>] [,<envelope section>]
                      [,<envelope section>] [,<envelope section>] [,<envelope section>]
                      -- COMMAND
ENV <envelope number> [,<envelope section>] [,<envelope section>]
                      [,<envelope section>] [,<envelope section>] [,<envelope section>]
                      -- COMMAND
EOF -- FUNCTION
ERASE <list of:<variable name> -- COMMAND
ERL -- FUNCTION
ERR -- FUNCTION
ERROR <whole number> -- COMMAND
EVERY <chronometer period>[,<chronometer number>] GOSUB <line number> -- COMMAND
EXP (<numerical expression>) -- FUNCTION
FILL <ink> -- COMMAND
FIX  (<numerical expression>) -- FUNCTION
FOR <simple variable>=<beginning> TO <end> [STEP <increment>] -- COMMAND
FRAME -- COMMAND
FRE (<numerical expression>) | FRE (<alphanumeric chain>) -- FUNCTION
GOSUB <line number> -- COMMAND
GOTO <line number> -- COMMAND
GRAPHICS PAPER <ink> -- COMMAND
GRAPHICS PEN [<ink>][,<paper mode>] -- COMMAND
HEX$ (<whole number without sign>[,<zone with>]) -- FUNCTION
HIMEM -- FUNCTION
IF (<logical expression>) THEN <option> [ELSE <option>] -- COMMAND
INK <ink>,<color number> [,<color number>] -- COMMAND
INKEY (<whole number>) -- FUNCTION
INKEY$ -- FUNCTION
INP(<port number>) -- FUNCTION
INPUT [#<channel number>,][;][<chain> <separator>] -- COMMAND
INSTR ( [<starting position>,]<chain containing>,<chain contained> ) -- FUNCTION
INT (<numerical expression>) -- FUNCTION
JOY (<whole number>) -- FUNCTION
KEY <logical key number>,<alphanumeric chain> -- COMMAND
KEY DEF <key number>,<repetition>[,<normal>[,<with shift>[,with control]]] -- COMMAND
LEFT$(<alphanumeric chain>,<necessary length>) -- FUNCTION
LEN (<alphanumeric chain>) -- FUNCTION
LET <variable>=<expression> -- COMMAND
LINE INPUT [#<channel number>,][;][<chain> <separator>] <variable alphanumeric> -- COMMAND
LIST [<unit of lines>][, #<channel number>] -- COMMAND
LOAD <filename>[,<adress>] -- COMMAND
LOCATE [#<channel number>,]<coordinate x>,<coordinate y> -- COMMAND
LOG (<numerical expression>) -- FUNCTION
LOG10 (<numerical expression>) -- FUNCTION
LOWER$ (<alphanumeric chain>) -- FUNCTION
MASK [<whole number>][,<layout of the first point>] -- COMMAND
MAX (<list of:<numerical expression>) -- FUNCTION
MEMORY <adress> -- COMMAND
MERGE <filename> -- COMMAND
MID$ (<alphanumeric chain>,<starting position>[,<length of under chain>]) -- FUNCTION
MID$ (<chain variable>,<insertion position>[,<lenght of the new chain>])
     = <new alphanumeric chain>
    -- COMMAND
MIN (<list of:<numerical expression>) -- FUNCTION
<argument 1> MOD <argument 2> -- OPERATOR
MODE <whole number> -- COMMAND
MOVE <coordinate x>,<coordinate y>[,[<ink>][,<ink mode>]] -- COMMAND
MOVER <interval x>,<interval y>[,[<ink>][,<ink mode>]] -- COMMAND
NEW -- COMMAND
NEXT [<list of: <variable>] -- COMMAND
NOT <argument> -- OPERATOR
ON BREAK CONT -- COMMAND
ON BREAK GOSUB <line number> -- COMMAND
ON BREAK STOP -- COMMAND
ON ERROR GOTO <line number> -- COMMAND
ON <selector> GOSUB <list of: <line number> -- COMMAND
ON <selector> GOTO <list of: <line number> --  COMMAND
ON SQ (<channel number>) GOSUB <line number> -- COMMAND
OPENIN <filename> -- COMMAND
OPENOUT <filename> -- COMMAND
<argument> OR <argument> -- OPERATOR
ORIGIN <x>,<y>[,<left>,<right>,<top>,<bottom>] -- COMMAND
OUT <port number>,<whole number> -- COMMAND
PAPER[#<channel number>,]<ink> -- COMMAND
PEEK (<adress>) -- FUNCTION
PEN [#<channel number>,][<ink>][,<paper mode>] -- COMMAND
PI -- FUNCTION
PLOT <coordinate x>,<coordinate y>[,[<ink>][,<ink mode>]] -- COMMAND
PLOTR <interval x>,<interval y>[,[<ink>][,<ink mode>]] -- COMMAND
POKE <adress>,<whole number> -- COMMAND
POS (#<channel number>) -- FUNCTION
PRINT [#<channel number>,][<list of: <article to print>] -- COMMAND
    PRINT SPC
    PRINT TAB
PRINT [#<channel number>,][<list of: <article to print>][;]
            [SPC(<whole number>)][<list of: <article to print>]
PRINT [#<channel number>,][<list of: <article to print>][;]
            [TAB(<whole number>)][<list of: <article to print>]

PRINT [#<channel number>][<list of:<article to print>][;]
            [USING<format model>][<separator> <expression>]
RAD -- COMMAND
RANDOMIZE [<numerical expression>] -- COMMAND
READ <list of:<variable> -- COMMAND
RELEASE <sound channels> -- COMMAND
REM <text> -- COMMAND
REMAIN (<chronometer number>) -- COMMAND
RENUM [<new line number>][,[<old line number>][,<increment>]] -- COMMAND
RESTORE [<line number>] -- COMMAND
RESUME [<line number>] -- COMMAND
RESUME NEXT -- COMMAND
RETURN -- COMMAND
RIGHT$ (<alphanumeric chain>,<required length>) -- FUNCTION
RND [ (<numerical expression>)] -- FUNCTION
ROUND (<numerical expression>[,<number of decimals>]) -- FUNCTION
RUN <alphanumeric chain> -- COMMAND
RUN [ <line number>] -- COMMAND
SAVE <filename>[,<type of file>][,<binary parameters>] -- COMMAND
SGN(<numerical expression>) -- FUNCTION
SIN(<numerical expression>) -- FUNCTION
SOUND <channel state>,<sound period>[,<duration>[,<volume>[,<volume envelope>,
            [<tonality envelope>[,<noise period>]]]]] -- COMMAND
SPACE$ (<whole number>) -- FUNCTION
SPEED INK <period 1>,<period 2> -- COMMAND
SPEED KEY <initial delay>,<inter-repetitions interval> -- COMMAND
SPEED WRITE <whole number> -- COMMAND
SQ (<channel number>) -- FUNCTION
SQR (<numerical expression>) -- FUNCTION
STOP -- COMMAND
STR$ (<numerical expression>) -- FUNCTION
STRING$ (<lenght>,<character>) -- FUNCTION
SYMBOL <character number>,<list of:<line> -- COMMAND
SYMBOL AFTER <whole number> -- COMMAND

TAG

TAG [#(<channel number>)]

    10 INPUT "input your name";a$:CLS
    20 PRINT"What comings and goings ";a$;" !!"
    30 TAG
    40 x=LEN(a$)*17:y=50+RND*300:MOVE -x,y
    50 FOR f=-x TO 640 STEP RND*7+3
    60 MOVE f,y:PRINT" ";a$;:FRAME:NEXT
    70 FOR b=640 TO -x STEP -RND*7+3
    80 MOVE b,y:PRINT a$;" ";:FRAME:NEXT
    90 GOTO 40
    run

COMMAND: Write the text specified to the position of the graphic cursor. This command makes it possible to input text and symbols into a graph and to move them rather pixel by pixel than character by character. The channel number takes by defect value 0.

The left beginning of the character strings positions on the graphic cursor (Text At Graphics). The control characters not visualized such as change of line or carriage return will not have any effect if instruction PRINT is finished by a semicolon; in the contrary case, they will appear in their graphic form.

If the channel indicator is #0 (by defect), BASIC cancels the command TAG when it come back in direct mode.

Associated key words: TAGOFF



TAGOFF

TAGOFF [#(<channel number>)]

    10 MODE 2:TAG:REM text with graphic coordonnees
    20 year=1984:FOR x=1 TO 640 STEP 60
    30 MOVE x,400:DRAWR 0,-350
    40 year=year+1:PRINT year;:NEXT
    50 TAGOFF:REM come back to the text coordinates
    60 LOCATE 28,25:PRINT"annual figures"
    70 GOTO 70
    run

COMMAND: Cancel the command TAG concerning the channel indicated (# 0 per defect). The text is thus again directed on the text cursor position.

Associated key words: TAG



TAN

TAN (<numerical expression>)

    PRINT TAN(45)
       1.61977519

FUNCTION: Calculate the TANgent of the (<numerical expression>), which must lie between -200000 and +200000.

One can express the argument in degrees or radians by the intermediary of the functions DEG and RAD, respectively.

Associated key words: ATN, COS, DEG, RAD, SIN



TEST

TEST (<coordinate x>,<coordinate y>)

    10 CLS
    20 PRINT"You use the pen number:";
    30 PRINT TEST(12,394)
    40 PRINT"Change mode and pen";
    50 PRINT"... and do RUN."
    run

FUNCTION: Place the graphic cursor at the position defined by x and y (in absolute coordinates) and indicates the value of the parameter <ink> to this place.

Associated key words: MOVE, MOVER, TESTR, XPOS, YPOS



TESTR

TESTR (<interval x>,<interval y>)

    10 MODE 0:FOR x=1 TO 15:LOCATE 1,x
    20 PEN x:PRINT STRING$(10,143);:NEXT
    30 MOVE 200,400:PEN 1
    40 FOR n=1 TO 23:LOCATE 12,n
    50 PRINT"pen";TESTR(0,-16):NEXT
    run

FUNCTION: Place the cursor on a position of coordinates x and y compared to its current position and indicates the value of the parameter <ink> to this place.

Associated key words: MOVE, MOVER, TEST, XPOS, YPOS



THEN

(See IF)


TIME

TIME

    10 CLS:REM clock
    20 INPUT "hour";hour
    30 INPUT "minute";minute
    40 INPUT "second";second
    50 CLS:x=INT(TIME/300)
    60 WHILE hour<13
    70 WHILE minute<60
    80 WHILE tic<60
    90 tic=(INT(TIME/300)-x)+second
    100 LOCATE 1,1
    110 PRINT USING "## ";hour;minute;tic
    120 WEND
    130 tic=0:second=0:minute=minute+1
    140 GOTO 50
    150 WEND
    160 minute=0:hour=hour+1
    170 WEND
    180 hour=1
    190 GOTO 60
    run

FUNCTION: Indicate the time passed since the powering of the computer or the last command RESET (the transfer times between the computer and the diskette drive are not counted).

At each second once corresponds the value: TIME/300.

Associated key words: AFTER, EVERY, WEND, WHILE


TO

(See FOR)


TROFF
TRON

TROFF
TRON

    10 TROFF:PRINT:PRINT"TROFF"
    20 FOR n=1 TO 8
    30 PRINT"The program run":NEXT
    40 IF f=1 THEN END
    50 TRON:PRINT:PRINT"TRON"
    60 f=1:GOTO 20
    run

COMMAND: Allows to follow the execution of a program by the posting of each number of line when the program run. This number is posted between hooks [ ]. This function is obtained with the command TRON. The command TROFF restores the normal execution mode. The command TRON is particularly interesting when one wishes to follow line by line the course of a program in order to correct an error.

Associated key words: Nothing



UNT

UNT (<adress>)

    PRINT UNT(&FF66)
       -154

COMMAND: Converts the argument  into a signed whole number ranging between -32768 and 32767.

Associated key words: CINT, FIX, INT, ROUND



UPPER$

UPPER$ (<alphanumeric chain>)

    10 CLS:a$="you were small but now you are tall !"
    20 PRINT UPPER$(a$)
    run

FUNCTION: Recopy the <alphanumeric chain> indicated by replacing with capital letters the alphabetical characters (A to Z) appearing in small letters. This function is used in particular for the treatment of entries where which are mixed capital letters and the tiny ones.

Associated key words: LOWER$


USING

(See PRINT USING)


VAL

VAL (<character string>)

    10 CLS:PRINT "I know my tables !"
    20 PRINT:PRINT"press a key (1-9)"
    30 a$=INKEY$:IF a$="" THEN 30
    40 n=VAL(a$):IF n<1 OR n>9 THEN 30
    50 FOR x=1 TO 12
    60 PRINT n;"X";x;"=";n*x
    70 NEXT:GOTO 20
    run

FUNCTION: Provides the numerical VALue of characters (including the negative sign and the decimal point) of the <alphanumeric chain> indicated.

Value 0 is obtained when the first character of the chain is not a figure. If the sign Â«-Â» appears in first character or if this one is a decimal point followed by a nonnumerical character, the error message Â«Type mismatchÂ» (typing error) (13) is posted to the screen.

Associated key words: STR$


VPOS

VPOS ( # <channel number>)

    10 MODE 1:BORDER 0:LOCATE 8,2
    20 PRINT"use the keys with arrows (high/low)"
    30 WINDOW 39,39,1,25:CURSOR 1,1
    40 LOCATE 1,13
    50 IF INKEY(0)<>-1 THEN PRINT CHR$(11);
    60 IF INKEY(2)<>-1 THEN PRINT CHR$(10);
    70 LOCATE #1,3,24
    80 PRINT#1,"text cursor ";
    90 PRINT#1,"vertical position =";
    100 PRINT#1,VPOS(#0):GOTO 50
    run

FUNCTION: Indicate, on the Vertical axis, the text cursor POSition, starting from the higher edge of the text window. The channel indicator must obligatorily appear; it does not take the value #0 by defect.

Associated key words: POS, WINDOW



WAIT

WAIT <I/O port number>,<mask>[,<inversion>]

    WAIT &FF34,20,25

COMMAND: Cause waiting until the input-outputs port indicated transmits a value ranging between 0 and 255; so that after having operated a XOR (OR exclusive) with the <mask>, then a AND with the <inversion> parameter, one obtains not a nil result.

The BASIC waits until the condition is checked.

This command is to be used with precaution.

Associated key words: INP, OUT



WEND

WEND

    WEND

COMMAND: Indicate the end of a program section executed inside a loop WHILE. The BASIC automatically recognizes the command WHILE with the WEND associated.

Associated key words: TIME, WHILE



WHILE

WHILE <logical expression>

    10 CLS:PRINT "10 seconds stop watch":t=TIME
    20 WHILE TIME<t*3000
    30 SOUND 1,0,100,15
    40 WEND:SOUND 129,40,30,15

COMMAND: Repeat a program section as long as a given condition is checked. The word WHILE indicates the beginning of the section to be executed and the <logical expression> defines the condition to check.

Associated key words: TIME, WEND



WIDTH

WIDTH <whole number>

    WIDTH 40

COMMAND: Indicate the maximum number of characters per line for a printout. The BASIC send automatically the carriage returns and the jumps of line necessary during the impression.

In the absence of a command WIDTH, the computer adopts by defect value 132. The command WIDTH 255 removes all the carriage returns and additional jumps of line leaving the printer the care to generate itself these characters. However, the carriage returns and normal jumps of line from the instruction PRINT continue to be sent unless the command PRINT is finished by one Â«;Â» or a comma.

Associated key words: POS



WINDOW

WINDOW [ # <channel number>,]<left>,<right>,<high>,<low>

    10 MODE 0:BORDER 0:REM tv
    20 INK 0,0:INK 1,25:INK 2,23:INK 3,21
    30 INK 4,17:INK 5,6:INK 6,2:INK 7,26
    40 PAPER 0:CLS
    50 PAPER 1:WINDOW 2,4,1,18:CLS
    60 PAPER 2:WINDOW 5,7,1,18:CLS
    70 PAPER 3:WINDOW 8,10,1,18:CLS
    80 PAPER 4:WINDOW 11,13,1,18:CLS
    90 PAPER 5:WINDOW 14,16,1,18:CLS
    100 PAPER 6:WINDOW 17,19,1,18:CLS
    110 PAPER 7:WINDOW 2,19,19,25:CLS
    120 GOTO 120
    run

COMMAND: In text mode, indicates the dimensions of a channel to the screen display (one speaks in this case about window). One will take care that the values of the parameters <left>, <right>, <high> and <low> correspond to the coordinates in the screen MODE used.

The <channel number> will take by defect the value #0

Associated key words: WINDOW SWAP



WINDOW SWAP

WINDOW SWAP <channel number>,<channel number>

    10 MODE 1:INK 1,24:INK 2,9:INK 3,6
    20 WINDOW 21,40,13,25:PAPER 3
    30 WINDOW #1,1,20,1,12:PAPER #1,2
    40 CLS:PRINT" Fenetre No 0"
    50 CLS #1:PRINT #1," Fenetre No 1"
    60 LOCATE 1,6
    70 PRINT" Fenetre Rouge (0)";SPC(2)
    80 LOCATE #1,1,6
    90 PRINT #1," Fenetre Verte (1)"
    100 FOR t=1 TO 1000:NEXT
    110 WINDOW SWAP 0,1:GOTO 60
    run

COMMAND: Inverts the first window and the second.

Both <channel numbers> must obligatorily appear without being preceded, in this precise case, by the channel  indicator #.

This command makes it possible to direct the BASIC messages to another channel that this one used by defect #0.

Associated key words: WINDOW



WRITE

WRITE [ # <channel number>,][<data to write>]

    10 REM write data on the diskette
    20 INPUT "give me a number";a
    30 INPUT "give me a string of characters";a$
    40 OPENOUT "FILENAME"
    50 WRITE #9,a,a$
    60 CLOSEOUT:PRINT "Data are saved on the diskette"
    run

COMMAND: Post or WRITE data on the channel indicated. Two distinct articles must be separated by a comma and the character strings are placed between quotation marks.

In our example, the entered data will be written on channel #9, i.e. recorded on diskette.

To find the data, one will use the program below:

    10 REM recover the data from the diskette
    20 OPENIN "FILENAME":INPUT #9,a,a$
    30 CLOSEIN:PRINT"the 2 data are:"
    40 PRINT:PRINT a,a$
    run

Associated key words: INPUT, LINE INPUT



XOR

<argument> XOR <argument>

    IF "alan" < "bernard" XOR "dog" > "cat" THEN PRINT "true" ELSE PRINT "false"
       false
    IF "bernard" < "alan" XOR "cat" > "dog" THEN PRINT "true" ELSE PRINT "false"
       false
    IF "alan" < "bernard" XOR "cat" > "dog" THEN PRINT "true" ELSE PRINT "false"
       true
     ....
    PRINT 1 XOR 1
       0
    PRINT 0 XOR 0
       0
    PRINT 1 XOR 0
       1

OPERATOR: Carry out bit by bit the boolean operation XOR (OR exclusive) on entireties. When bits of two arguments are not identical, the resulting bit is 1.

Associated key words: AND, OR, NOT


XPOS

XPOS

    10 MODE 1:DRAW 320,200
    20 PRINT"POSition X of the graphic cursor=";
    30 PRINT XPOS
    run

FUNCTION: Indicate, on the horizontal axis (X), the POSition of the graphic cursor.

Associated key words: MOVE, MOVER, ORIGIN, YPOS



YPOS

YPOS

    10 MODE 1:DRAW 320,200
    20 PRINT"POSition Y of the graphic cursor=";
    30 PRINT YPOS
    run

FUNCTION: Indicate, on the vertical axis (Y), the POSition of the graphic cursor.

Associated key words: MOVE, MOVER, ORIGIN, XPOS



ZONE

ZONE <whole number>

    10 CLS:FOR z=2 TO 20
    20 ZONE z
    30 PRINT "X","X ZONE ";z:NEXT
    run

COMMAND: Modify the width of the tabulation indicated by the comma in the command PRINT. The width of the posting or impression zones, (about 13 characters per defect), can thus take an unspecified whole value between 1 and 255.

Associated key words: PRINT