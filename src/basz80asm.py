"""
Translates intermediate code generated by the Emitter object
to Amstrad CPC Z80 Assembly language in Maxam/WinAPE style.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation in its version 3.

This program is distributed in the hope that it will be useful
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
"""

import sys
import basz80lib
from bastypes import BASTypes

# Stack machine to Z80 code fragments 
SM2Z80 = {
'NOP': [],
'LABEL': ["$ARG1:"],
'REM': ["; $ARG1"], 
'PUSH': ["push hl"],
'CLEAR': ["ld hl,0"],
'DROP': ["pop de"],
'LDVAL': ["ld hl,$ARG1"],
'LDADDR': ["ld hl,$ARG1"],
'LDLREF': [
    "ld hl,$ARG1",
    "push ix",
    "pop de",
    "add hl,de"
    ],
'LDGLOB': ["ld hl,($ARG1)"],
'LDLOCL': [
    "ld h,(ix+H)",
    "ld l,(ix+L)"
    ],
'STGLOB': ["ld ($ARG1),hl"],
'STLOCL': [
    "ld (ix+H),h",
	"ld (ix+L),l"
    ],
'STINDR': [
    "ex de,hl",
    "pop hl",
    "ld (hl),e",
    "inc hl",
	"ld (hl),d"
    ],
'STINDB': [
    "ex de,hl",
    "pop hl",
	"ld (hl),e"
    ],
'INCGLOB': [
    "ld hl,$ARG1",
    "inc (hl)",
    "jrnz +2",
    "inc hl",
    "inc (hl)"
    ],
'INCLOCL': [
    "inc (ix+L)",
    "jrnz +3",
    "inc (ix+H)"
    ],
'INCR': [
    "ld de,$ARG1",
    "add hl,de"
    ],
'STACK': [
    "ld hl,$ARG1",
    "add hl,sp",
    "ld sp,hl"
    ],
'UNSTACK': [
    "ex de,hl",
    "ld hl,$ARG1",
	"add hl,sp",
    "ld sp,hl",
	"ex de,hl"
    ],
'LOCLVEC': ["push hl"],
'GLOBVEC': ["ld ($ARG1),hl"],
'INDEX': [
    "add hl,hl",
    "pop de",
	"add hl,de"
    ],
'DEREF': [
    "ld a,(hl)",
    "inc hl",
	"ld h,(hl)",
    "ld l,a"
    ],
'INDXB': [
    "pop de",
    "add hl,de"
    ],
'DREFB': [
    "ld l,(hl)",
    "ld h,0"
    ],
'CALL': ["call $ARG1"],
'CALR': ["call &014A"],  # AAA Revisar
'JUMP': ["jp $ARG1"],
'RJUMP': ["jr $ARG1"],  # being $ARG1 = $L in original code
'JMPFALSE': [
    "ld a,h",
    "or l",
	"jpz $ARG1"
    ],
'JMPTRUE': [
    "ld a,h",
    "or l",
	"jpnz $ARG1"
    ],
'FOR': [
    "pop de",
    "ex de,hl",
	"xor a",
    "sbc hl,de",
    "jpp $ARG1"
    ],
'FORDOWN': [
    "pop de",
    "xor a",
	"sbc hl,de",
    "jpp $ARG1"
    ],
'MKFRAME': [
    "push ix",
    "ld ix,0",
	"add ix,sp"
    ],
'DELFRAME': ["pop ix"],
'RET': ["ret"],
'HALT': ["jp 0"],
'NEG': [
    "ld de,0",
    "ex de,hl",
	"xor a",
    "sbc hl,de"
    ],
'INV': [
    "ld de,&FFFF",
	"ex de,hl",
    "xor a",
	"sbc hl,de"
    ],
'LOGNOT': [
    "ex de,hl",
	"ld hl,&FFFF",
    "ld a,d",
	"or e",
    "jrnz +1",
    "inc hl"
    ],
'ADD': [
    "pop de",
    "add hl,de"
    ],
'SUB': [
    "pop de",
    "ex de,hl",
    "xor a",
    "sbc hl,de"
    ],
'MUL': [
    "pop de",
    "call &0108"  # AAA Revisar
    ],
'DIV': [
    "pop de",
    "call &010B"  # AAA Revisar
    ],
'MOD': [        
    "pop de",
    "call &010E"  # AAA Revisar
    ],
'AND': [
    "pop de",
    "ld a,h",
	"and d",
    "ld h,a",
	"ld a,l",
    "and e",
	"ld l,a"
    ],
'OR': [
    "pop de",
    "ld a,h",
	"or d",
    "ld h,a",
	"ld a,l",
    "or e",
	"ld l,a"
    ],
'XOR': [
    "pop de",
    "ld a,h",
	"xor d",
    "ld h,a",
	"ld a,l",
    "xor e",
	"ld l,a"
    ],
'SHL': [
    "pop de",
    "ex de,hl",
    "ld b,e",
    "add hl,hl",
	"djnz -3"
    ],
'SHR': [
    "pop de",
    "ex de,hl",
	"ld b,e",
    "srl h",
	"rr l",
    "djnz -6"
    ],
'EQ': [
    "pop de",
    "xor a"
    "sbc hl,de",
	"ld hl,&FFFF",
	"jrz +1",
    "inc hl"
    ],
'NE': [
    "pop de",
    "xor a",
	"sbc hl,de",
	"ld hl,&FFFF",
	"jrnz +1",
    "inc hl"
    ],
'LT': [
    "pop de",
    "ex de,hl",
	"call &0117", # AAA revisar
	"ld hl,&FFFF",
	"jrc +1",
    "inc hl"
    ],
'GT': [
    "pop de",
    "call &0117", # AAA revisar
	"ld hl,&FFFF",
	"jrc +1",
    "inc hl"
    ],
'LE': [
    "pop de",
    "call &0117",
    "ld hl,0",
    "jrc +1",
    "dec hl"
    ],
'GE': [
    "pop de",
    "ex de,hl",
	"call &0117", # AAA revisar
    "ld hl,0",
    "jrc +1",
    "dec hl"
    ],
'UMUL': [
    "pop de",
    "call &0111" # AAA revisar
    ],
'UDIV': [
    "pop de",
    "ex de,hl",
    "call &0114" # AAA revisar
    ],
'ULT': [
    "pop de",
    "ex de,hl",
    "xor a",
    "sbc hl,de",
	"ld hl,&FFFF",
	"jrc +1",
    "inc hl"
    ],
'UGT': [
    "pop de",
    "xor a",
    "sbc hl,de",
	"ld hl,&FFFF",
	"jrc +1",
    "inc hl"
    ],
'ULE': [
    "pop de",
    "xor a",
    "sbc hl,de",
	"ld hl,0",
	"jrc +1",
    "dec hl"
    ],
'UGE': [
    "pop de",
    "ex de,hl",
	"xor a",
    "sbc hl,de",
	"ld hl,0",
	"jrc +1",
    "dec hl"
    ],
'JMPEQ': [
    "pop de",
    "xor a",
    "sbc hl,de",
    "jpz $ARG1"
    ],
'JMPNE': [
    "pop de",
    "xor a",
    "sbc hl,de",
    "jpnz $ARG1"
    ],
'JMPLT': [
    "pop de",
    "ex de,hl",
    "xor a",
    "sbc hl,de",
    "jpm $ARG1"
    ],
'JMPGT': [
    "pop de",
    "xor a",
    "sbc hl,de",
    "jpm $ARG1"
    ],
'JMPLE': [
    "pop de",
    "xor a",
    "sbc hl,de",
    "jpp $ARG1"
    ],
'JMPGE': [
    "pop de",
    "ex de,hl",
	"xor a",
    "sbc hl,de",
    "jpp $ARG1"
    ],
'JMPULT': [
    "pop de",
    "ex de,hl",
	"xor a",
    "sbc hl,de",
    "jpc $ARG1"
    ],
'JMPUGT': [
    "pop de",
    "xor a",
	"sbc hl,de",
    "jpc $ARG1"
    ],
'JMPULE': [
    "pop de",
    "xor a",
    "sbc hl,de",
    "jpnc $ARG1"
    ],
'JMPUGE': [
    "pop de",
    "ex de,hl",
	"xor a",
    "sbc hl,de",
    "jpnc $ARG1"
    ],
'SKIP': ["jp $ARG1"]
}

class FWCALL:
    TXT_CLEAR_WINDOW    = "&BB6C"
    TXT_CURSOR_ON       = "&BB81"
    TXT_CURSOR_OFF      = "&BB84"
    SCR_SET_MODE        = "&BC0E"

class Z80Backend:
    """
    Generates code for Amstrad CPC in Z80 Assembly language (Maxam/WinAPE style)
    """

    def __init__(self):
        self.symbols = None
        self.icode = []
        self.libcode = []   # reusable and utility asm subroutines
        self.code = []      # program code
        self.data = []      # data/constants declaration area    

    def abort(self, message):
        print("Fatal error:", message)
        sys.exit(1)

    def save_output(self):
        with open(self.outputfile, 'w  ') as ofd:
            ofd.writelines(self.libcode)
            ofd.writelines(self.code)
            ofd.writelines(self.data)
        return self.outputfile


    def emitlibcode(self, code):
        self.libcode.append(code + '\n')

    def emitcode(self, inst, arg, prefix):
        if inst == "LIBCALL":
            # BASIC original function
            self.emit_rtcall(arg)
        elif inst in SM2Z80:
            code = SM2Z80[inst]
            for line in code:
                if arg != None: line = line.replace('$ARG1', arg)
                self.code.append(prefix + line + '\n')
        else:
            self.abort(f"intermediate op-code {inst} is unknown")

    def emitdata(self, code):
        self.data.append(code + '\n')

    def generatecode(self, orgaddr):
        self.code.append('org &%04X\n' % orgaddr)
        for inst, arg, prefix in self.icode:
            self.emitcode(inst, arg, prefix)

        for symname in self.symbols.getsymbols():
            symbol = self.symbols.get(symname)
            if symbol.valtype == BASTypes.INT:
                self.emitdata(f'{symbol.symbol}: dw 0')
            elif symbol.valtype == BASTypes.REAL:
                self.emitdata(f'{symbol.symbol}: dw 0,0')
            elif symbol.valtype == BASTypes.STR:
                if symbol.is_constant():
                    self.emitdata(f'{symbol.symbol}: db "{symbol.value[0]}",&00')
                else:    
                    self.emitdata(f'{symbol.symbol}: defs 255')
            else:
                # None, this symbol was a label
                pass

    def save_output(self, outputfile, icode, symbols, startaddr = 0x4000):
        """
        outputfile: output file where assembly code will be written
        icode: Intermediate code generated by the Emitter
        symbols: SymbolTable generated by the parser
        startaddr: Starting memory position for the code generated
        """
        self.symbols = symbols
        self.icode = icode
        self.generatecode(startaddr)
        with open(outputfile, "w") as fd:
            fd.writelines(self.code)
            fd.writelines(self.libcode)
            fd.writelines(self.data)

    # BASIC commands and functions

    def emit_rtcall(self, fun):
        fun_cb = getattr(self, "rtcall_" + fun, None)
        if fun_cb == None:
            print("Emitter error:", fun, "call is not implemented yet")
        else:
            fun_cb()

    def _addcode(self, line):
        self.code.append(line + '\n')

    def rtcall_CLS(self):
        self._addcode("\tpush    hl")
        self._addcode("\tcall    " + FWCALL.TXT_CLEAR_WINDOW + " ;TXT_CLEAR_WINDOW")
        self._addcode("\tpop     hl")

    def rtcall_MODE(self):
        self._addcode("\tpush    af")
        self._addcode("\tld      a,l")
        self._addcode("\tpush    hl")
        self._addcode("\tcall    " + FWCALL.SCR_SET_MODE  + " ;SCR_SET_MODE")
        self._addcode("\tpop     hl")
        self._addcode("\tpop     af")

    def rtcall_PRINT(self):
        pass