"""
Translates intermediate code generated by the Emitter object
to Amstrad CPC Z80 Assembly language in Maxam/WinAPE style.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation in its version 3.

This program is distributed in the hope that it will be useful
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
"""

import basz80lib
from bastypes import Symbol, SymbolTable, Expression, BASTypes

class FWCALL:
    TXT_CLEAR_WINDOW    = "&BB6C"
    TXT_CURSOR_ON       = "&BB81"
    TXT_CURSOR_OFF      = "&BB84"
    SCR_SET_MODE        = "&BC0E"

class Z80Backend:
    """
    Generates code for Amstrad CPC in Z80 Assembly language (Maxam/WinAPE style)
    """

    def __init__(self):
        self.symbols = None
        self.icode = []
        self.libcode = []   # reusable and utility asm subroutines
        self.code = []      # program code
        self.data = []      # data/constants declaration area
        

    def save_output(self):
        with open(self.outputfile, 'w') as ofd:
            ofd.writelines(self.libcode)
            ofd.writelines(self.code)
            ofd.writelines(self.data)
        return self.outputfile


    def emitlibcode(self, code):
        self.libcode.append(code + '\n')

    def emitcode(self, code):
        self.code.append(code + '\n')

    def emitdata(self, code):
        self.data.append(code + '\n')

    def emit_rtcall(self, fun, args = []):
        fun_cb = getattr(self, "rtcall_" + fun, None)
        if fun_cb == None:
            print("Emitter error:", fun, "call is not implemented yet")
        else:
            fun_cb(args)

    def rtcall_CLS(self, args):
        self.emitcode("\tpush    hl")
        self.emitcode("\tcall    " + FWCALL.TXT_CLEAR_WINDOW + " ;TXT_CLEAR_WINDOW")
        self.emitcode("\tpop     hl")

    def rtcall_MODE(self, expr):
        self.emitcode("\tpush    af")
        self.emitcode("\tld      a,%s" % expr.expr[0])
        self.emitcode("\tpush    hl")
        self.emitcode("\tcall    " + FWCALL.SCR_SET_MODE  + " ;SCR_SET_MODE")
        self.emitcode("\tpop     hl")
        self.emitcode("\tpop     af")

    def generatecode(self, orgaddr):
        self.emitcode("org     &%04X" % orgaddr)
        # TODO: temporal 'hack' to see intermediate code
        for ins in self.icode:
            self.emitcode(ins)

    def save_output(self, outputfile, icode, symbols, startaddr = 0x4000):
        """
        outputfile: output file where assembly code will be written
        icode: Intermediate code generated by the Emitter
        symbols: SymbolTable generated by the parser
        startaddr: Starting memory position for the code generated
        """
        self.symbols = symbols
        self.icode = icode
        self.generatecode(startaddr)
        with open(outputfile, "w") as fd:
            fd.writelines(self.code)
            fd.writelines(self.libcode)
            fd.writelines(self.data)

            